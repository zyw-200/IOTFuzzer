// debug.c
//
// Generated by C DriverWizard 3.2.0 (Build 2485)
// Requires DDK Only
// File created on 11/15/2005
//

#include "pch.h"
#ifdef TESTDRV_WMI_TRACE
#include "debug.tmh"
#else

#if DBG

#define NUMBER_DEBUG_BUFFERS    (sizeof(g_DebugBufferBusy)/sizeof(g_DebugBufferBusy[0]))

// debug level and debug area mask
ULONG   g_DebugLevel = DBG_INFO;
ULONG   g_DebugArea = DBG_ALL;

// Buffers for debug messages are allocated globally instead of 
// on a stack, therefore we need g_DebugBufferBusy flags to 
// protect access to them.
LONG    g_DebugBufferBusy[] = {0, 0, 0, 0, 0, 0, 0, 0}; 
CHAR    g_DebugBuffer[NUMBER_DEBUG_BUFFERS][1024];

///////////////////////////////////////////////////////////////////////////////////////////////////
//  testdrvDebugPrint
//      Debug messages output routine.
//
//  Arguments:
//      IN  Area
//              Debug area (DBG_PNP, DBG_POWER, etc..)
//
//      IN  Level
//              Debug Level (DBG_ERR, DBG_INFO, etc..)
//
//      IN  Format
//              Debug Message Format
//
//  Return Value:
//      None.
//
VOID testdrvDebugPrint(
    IN ULONG    Area,
    IN ULONG    Level,
    IN PCCHAR   Format,
    IN          ...
    )
{
    ULONG i;
    va_list vaList;

    va_start(vaList, Format);

    // check mask for debug area and debug level
    if ((g_DebugArea & Area) && (Level <= g_DebugLevel))
    {
        // find a free buffer
        for (i = 0; i < NUMBER_DEBUG_BUFFERS; ++i)
        {
            if (InterlockedCompareExchange(&g_DebugBufferBusy[i], 1, 0) == 0)
            {
                NTSTATUS status;

                status = RtlStringCbVPrintfA(
                            g_DebugBuffer[i], 
                            sizeof(g_DebugBuffer[i]),
                            Format,
                            vaList
                            );

                if (Level == DBG_ERR)
                {
                    DbgPrint("TESTDRV(IRQL %2.2d): ERROR %s !!!!!\n", KeGetCurrentIrql(), g_DebugBuffer[i]); 
                }
                else if (Level == DBG_WARN)
                {
                    DbgPrint("TESTDRV(IRQL %2.2d): WARNING %s\n", KeGetCurrentIrql(), g_DebugBuffer[i]); 
                }
                else if (Level == DBG_INFO)
                {
                    DbgPrint("TESTDRV(IRQL %2.2d):     %s\n", KeGetCurrentIrql(), g_DebugBuffer[i]); 
                }
                else
                {
                    DbgPrint("TESTDRV(IRQL %2.2d): %s\n", KeGetCurrentIrql(), g_DebugBuffer[i]); 
                }

                InterlockedExchange(&g_DebugBufferBusy[i], 0);
                break;
            }
        }
    }

    va_end(vaList);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  testdrvDumpIrp
//      Dump Irp fields to the debugger.
//
//  Arguments:
//      IN  Irp
//              Irp to display
//
//  Return Value:
//      None.
//
VOID testdrvDumpIrp(
    IN PIRP Irp
    )
{
    ULONG               debugArea;
    PIO_STACK_LOCATION  irpStack;

    // Get our current IRP stack location
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // determine debug area
    switch (irpStack->MajorFunction)
    {
    case IRP_MJ_PNP:
        debugArea = DBG_PNP;
        break;
    case IRP_MJ_POWER:
        debugArea = DBG_POWER;
        break;
    case IRP_MJ_CREATE:
    case IRP_MJ_CLOSE:
    case IRP_MJ_CLEANUP:
        debugArea = DBG_CREATECLOSE;
        break;
    case IRP_MJ_SYSTEM_CONTROL:
        debugArea = DBG_WMI;
        break;
    case IRP_MJ_READ:
    case IRP_MJ_WRITE:
    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        debugArea = DBG_IO;
        break;
    default:
        debugArea = DBG_GENERAL;
        break;
    }

    testdrvDebugPrint(debugArea, DBG_INFO, "IRP %p %s", Irp, IrpMajorFunctionString(irpStack->MajorFunction));

    if (irpStack->MajorFunction == IRP_MJ_PNP)
    {
        testdrvDebugPrint(debugArea, DBG_INFO, "%s", PnPMinorFunctionString(irpStack->MinorFunction));
    }
    else if (irpStack->MajorFunction == IRP_MJ_POWER)
    {
        testdrvDebugPrint(debugArea, DBG_INFO, "%s", PowerMinorFunctionString(irpStack->MinorFunction));

        if (irpStack->Parameters.Power.Type == SystemPowerState)
        {
            testdrvDebugPrint(debugArea, DBG_INFO, "%s", SystemPowerStateString(irpStack->Parameters.Power.State.SystemState));
        }
        else
        {
            testdrvDebugPrint(debugArea, DBG_INFO, "%s", DevicePowerStateString(irpStack->Parameters.Power.State.DeviceState));
        }
    }
    else if (irpStack->MajorFunction == IRP_MJ_SYSTEM_CONTROL)
    {
        testdrvDebugPrint(debugArea, DBG_INFO, "%s", WMIMinorFunctionString(irpStack->MinorFunction));
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  IrpMajorFunctionString
//      Function for debug prints to return the text description of the
//      IRP's major function code
//
//  Arguments:
//      IN  MajorFunction
//              Major function of the IRP being processed
//
//  Return Value:
//      returns the major function string
//
PCHAR IrpMajorFunctionString(
    IN  UCHAR MajorFunction
    )
{
    switch (MajorFunction)
    {
    case IRP_MJ_CREATE:
        return "IRP_MJ_CREATE";
    case IRP_MJ_CREATE_NAMED_PIPE:
        return "IRP_MJ_CREATE_NAMED_PIPE";
    case IRP_MJ_CLOSE:
        return "IRP_MJ_CLOSE";
    case IRP_MJ_READ:
        return "IRP_MJ_READ";
    case IRP_MJ_WRITE:
        return "IRP_MJ_WRITE";
    case IRP_MJ_QUERY_INFORMATION:
        return "IRP_MJ_QUERY_INFORMATION";
    case IRP_MJ_SET_INFORMATION:
        return "IRP_MJ_SET_INFORMATION";
    case IRP_MJ_QUERY_EA:
        return "IRP_MJ_QUERY_EA";
    case IRP_MJ_SET_EA:
        return "IRP_MJ_SET_EA";
    case IRP_MJ_FLUSH_BUFFERS:
        return "IRP_MJ_FLUSH_BUFFERS";
    case IRP_MJ_QUERY_VOLUME_INFORMATION:
        return "IRP_MJ_QUERY_VOLUME_INFORMATION";
    case IRP_MJ_SET_VOLUME_INFORMATION:
        return "IRP_MJ_SET_VOLUME_INFORMATION";
    case IRP_MJ_DIRECTORY_CONTROL:
        return "IRP_MJ_DIRECTORY_CONTROL";
    case IRP_MJ_FILE_SYSTEM_CONTROL:
        return "IRP_MJ_FILE_SYSTEM_CONTROL";
    case IRP_MJ_DEVICE_CONTROL:
        return "IRP_MJ_DEVICE_CONTROL";
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        return "IRP_MJ_INTERNAL_DEVICE_CONTROL";
    case IRP_MJ_SHUTDOWN:
        return "IRP_MJ_SHUTDOWN";
    case IRP_MJ_LOCK_CONTROL:
        return "IRP_MJ_LOCK_CONTROL";
    case IRP_MJ_CLEANUP:
        return "IRP_MJ_CLEANUP";
    case IRP_MJ_CREATE_MAILSLOT:
        return "IRP_MJ_CREATE_MAILSLOT";
    case IRP_MJ_QUERY_SECURITY:
        return "IRP_MJ_QUERY_SECURITY";
    case IRP_MJ_SET_SECURITY:
        return "IRP_MJ_SET_SECURITY";
    case IRP_MJ_POWER:
        return "IRP_MJ_POWER";
    case IRP_MJ_SYSTEM_CONTROL:
        return "IRP_MJ_SYSTEM_CONTROL";
    case IRP_MJ_DEVICE_CHANGE:
        return "IRP_MJ_DEVICE_CHANGE";
    case IRP_MJ_QUERY_QUOTA:
        return "IRP_MJ_QUERY_QUOTA";
    case IRP_MJ_SET_QUOTA:
        return "IRP_MJ_SET_QUOTA";
    case IRP_MJ_PNP:
        return "IRP_MJ_PNP";
    default:
        return "Unknown IRP Request";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  PnPMinorFunctionString
//      Function for debug prints to return the text description of the
//      IRP's minor function code
//
//  Arguments:
//      IN  MinorFunction
//              Minor function of the IRP being processed
//
//  Return Value:
//      returns the minor function string
//
PCHAR PnPMinorFunctionString(
    IN  UCHAR MinorFunction
    )
{
    switch (MinorFunction)
    {
    case IRP_MN_START_DEVICE:
        return "IRP_MN_START_DEVICE";
    case IRP_MN_QUERY_REMOVE_DEVICE:
        return "IRP_MN_QUERY_REMOVE_DEVICE";
    case IRP_MN_REMOVE_DEVICE:
        return "IRP_MN_REMOVE_DEVICE";
    case IRP_MN_CANCEL_REMOVE_DEVICE:
        return "IRP_MN_CANCEL_REMOVE_DEVICE";
    case IRP_MN_STOP_DEVICE:
        return "IRP_MN_STOP_DEVICE";
    case IRP_MN_QUERY_STOP_DEVICE:
        return "IRP_MN_QUERY_STOP_DEVICE";
    case IRP_MN_CANCEL_STOP_DEVICE:
        return "IRP_MN_CANCEL_STOP_DEVICE";
    case IRP_MN_QUERY_DEVICE_RELATIONS:
        return "IRP_MN_QUERY_DEVICE_RELATIONS";
    case IRP_MN_QUERY_INTERFACE:
        return "IRP_MN_QUERY_INTERFACE";
    case IRP_MN_QUERY_CAPABILITIES:
        return "IRP_MN_QUERY_CAPABILITIES";
    case IRP_MN_QUERY_RESOURCES:
        return "IRP_MN_QUERY_RESOURCES";
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
    case IRP_MN_QUERY_DEVICE_TEXT:
        return "IRP_MN_QUERY_DEVICE_TEXT";
    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
        return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
    case IRP_MN_READ_CONFIG:
        return "IRP_MN_READ_CONFIG";
    case IRP_MN_WRITE_CONFIG:
        return "IRP_MN_WRITE_CONFIG";
    case IRP_MN_EJECT:
        return "IRP_MN_EJECT";
    case IRP_MN_SET_LOCK:
        return "IRP_MN_SET_LOCK";
    case IRP_MN_QUERY_ID:
        return "IRP_MN_QUERY_ID";
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
        return "IRP_MN_QUERY_PNP_DEVICE_STATE";
    case IRP_MN_QUERY_BUS_INFORMATION:
        return "IRP_MN_QUERY_BUS_INFORMATION";
    case IRP_MN_DEVICE_USAGE_NOTIFICATION:
        return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
    case IRP_MN_SURPRISE_REMOVAL:
        return "IRP_MN_SURPRISE_REMOVAL";
    case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
        return "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";
    default:
        return "Unknown PnP Request";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  PowerMinorFunctionString
//      Function for debug prints to return the text description of the
//      IRP's minor function code
//
//  Arguments:
//      IN  MinorFunction
//              Minor function of the IRP being processed
//
//  Return Value:
//      returns the minor function string
//
PCHAR PowerMinorFunctionString(
    IN  UCHAR MinorFunction
    )
{
    switch (MinorFunction)
    {
    case IRP_MN_SET_POWER:
        return "IRP_MN_SET_POWER";
    case IRP_MN_QUERY_POWER:
        return "IRP_MN_QUERY_POWER";
    case IRP_MN_WAIT_WAKE:
        return "IRP_MN_WAIT_WAKE";
    case IRP_MN_POWER_SEQUENCE:
        return "IRP_MN_POWER_SEQUENCE";
    default:
        return "Unknown Power Request";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  SystemPowerStateString
//      Returns SYSTEM_POWER_STATE as a string
//
//  Arguments:
//      IN  SystemState
//              SYSTEM_POWER_STATE
//
//  Return Value:
//      returns the SYSTEM_POWER_STATE string
//
PCHAR SystemPowerStateString(
    IN  SYSTEM_POWER_STATE  SystemState
    )
{
    switch (SystemState)
    {
    case PowerSystemUnspecified:
        return "PowerSystemUnspecified";
    case PowerSystemWorking:
        return "PowerSystemWorking";
    case PowerSystemSleeping1:
        return "PowerSystemSleeping1";
    case PowerSystemSleeping2:
        return "PowerSystemSleeping2";
    case PowerSystemSleeping3:
        return "PowerSystemSleeping3";
    case PowerSystemHibernate:
        return "PowerSystemHibernate";
    case PowerSystemShutdown:
        return "PowerSystemShutdown";
    case PowerSystemMaximum:
        return "PowerSystemMaximum";
    default:
        return "PowerSystemUnknown";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  DevicePowerStateString
//      Returns DEVICE_POWER_STATE as a string
//
//  Arguments:
//      IN  DeviceState
//              DEVICE_POWER_STATE
//
//  Return Value:
//      returns the DEVICE_POWER_STATE string
//
PCHAR DevicePowerStateString(
    IN  DEVICE_POWER_STATE  DeviceState
    )
{
    switch (DeviceState)
    {
    case PowerDeviceUnspecified:
        return "PowerDeviceUnspecified";
    case PowerDeviceD0:
        return "PowerDeviceD0";
    case PowerDeviceD1:
        return "PowerDeviceD1";
    case PowerDeviceD2:
        return "PowerDeviceD2";
    case PowerDeviceD3:
        return "PowerDeviceD3";
    case PowerDeviceMaximum:
        return "PowerDeviceMaximum";
    default:
        return "PowerDeviceUnknown";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  WMIMinorFunctionString
//      Function for debug prints to return the text description of the
//      IRP's minor function code
//
//  Arguments:
//      IN  MinorFunction
//              Minor function of the IRP being processed
//
//  Return Value:
//      returns the minor function string
//
PCHAR WMIMinorFunctionString (
    IN  UCHAR MinorFunction
    )
{
    switch (MinorFunction)
    {
    case IRP_MN_CHANGE_SINGLE_INSTANCE:
        return "IRP_MN_CHANGE_SINGLE_INSTANCE";
    case IRP_MN_CHANGE_SINGLE_ITEM:
        return "IRP_MN_CHANGE_SINGLE_ITEM";
    case IRP_MN_DISABLE_COLLECTION:
        return "IRP_MN_DISABLE_COLLECTION";
    case IRP_MN_DISABLE_EVENTS:
        return "IRP_MN_DISABLE_EVENTS";
    case IRP_MN_ENABLE_COLLECTION:
        return "IRP_MN_ENABLE_COLLECTION";
    case IRP_MN_ENABLE_EVENTS:
        return "IRP_MN_ENABLE_EVENTS";
    case IRP_MN_EXECUTE_METHOD:
        return "IRP_MN_EXECUTE_METHOD";
    case IRP_MN_QUERY_ALL_DATA:
        return "IRP_MN_QUERY_ALL_DATA";
    case IRP_MN_QUERY_SINGLE_INSTANCE:
        return "IRP_MN_QUERY_SINGLE_INSTANCE";
    case IRP_MN_REGINFO:
        return "IRP_MN_REGINFO";
    default:
        return "Unknown System Control Request";
    }
}

#endif	// DBG
#endif	// TESTDRV_WMI_TRACE

