// testdrv.c
//
// Generated by C DriverWizard 3.2.0 (Build 2485)
// Requires DDK Only
// File created on 11/15/2005
//

#include "pch.h"
#include "..\intrface.h"
#ifdef TESTDRV_WMI_TRACE
#include "testdrv.tmh"
#endif

#pragma warning(disable: 200)

#include "ProcMMap.h"

// global data
TESTDRV_DATA g_Data;

NTSYSAPI
NTSTATUS NTAPI ZwQueryInformationProcess (
 IN HANDLE ProcessHandle,
 IN PROCESSINFOCLASS ProcessInformationClass,
 OUT PVOID ProcessInformation, 
 IN ULONG ProcessInformationLength,
 OUT PULONG ReturnLength OPTIONAL
 );

 


VOID static LoadImageNotifyRoutine (
    IN PUNICODE_STRING  FullImageName,
    IN HANDLE  ProcessId, // where image is mapped
    IN PIMAGE_INFO  ImageInfo
    )
{
	
//	DbgPrint("Load Image: <%wZ> \nPid=%5d, Base=%08x, Size=%8x \n", FullImageName, 
//		ProcessId, ImageInfo->ImageBase, ImageInfo->ImageSize);


	SysTntInsertModuleInfo((ULONG)ProcessId, FullImageName, (ULONG)ImageInfo->ImageBase, 
				ImageInfo->ImageSize);

}



VOID static CreateProcessNotifyRoutine (
    IN HANDLE  ParentId,
    IN HANDLE  ProcessId,
    IN BOOLEAN  Create
    )
{
	if(Create) 
		CreateProcMMap((ULONG)ProcessId, (ULONG)ParentId);
	else
		RemoveProcMMap((ULONG)ProcessId);

}

PIO_WORKITEM g_WorkItem;
extern LIST_ENTRY ModuleListHead;


VOID GetSysModInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
	PIO_WORKITEM wi = (PIO_WORKITEM)Context;
	UpdateSysModuleList();
	IoFreeWorkItem(wi);
}



///////////////////////////////////////////////////////////////////////////////////////////////////
//  DriverEntry 
//      Installable driver initialization entry point.
//      This entry point is called directly by the I/O system.
//
//  Arguments:
//      IN  DriverObject
//              pointer to the driver object
//
//      IN  RegistryPath
//              pointer to a unicode string representing the path,
//              to driver-specific key in the registry.
//
//  Return Value:
//      Status
//
NTSTATUS DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS                            status;
    PDEVICE_OBJECT                      deviceObject;
    PTESTDRV_DEVICE_EXTENSION   deviceExtension;
    UNICODE_STRING                      ntName;
    UNICODE_STRING                      win32Name;

    testdrvDebugPrint(DBG_INIT, DBG_TRACE, __FUNCTION__"++");
    testdrvDebugPrint(DBG_INIT, DBG_INFO, "Compiled at %s on %s", __TIME__, __DATE__);

#ifdef DBG
//    DbgBreakPoint();
#endif

#ifdef TESTDRV_WMI_TRACE 
    WPP_INIT_TRACING(DriverObject, RegistryPath);
#endif

    RtlZeroMemory(&g_Data, sizeof(TESTDRV_DATA));

    // save registry path
    g_Data.RegistryPath.Length = RegistryPath->Length;
    g_Data.RegistryPath.MaximumLength = RegistryPath->Length + sizeof(UNICODE_NULL);
    g_Data.RegistryPath.Buffer = (PWCHAR)ExAllocatePoolWithTag(
                                            PagedPool,
                                            g_Data.RegistryPath.MaximumLength,
                                            TESTDRV_POOL_TAG
                                            );

    if (g_Data.RegistryPath.Buffer == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;

        testdrvDebugPrint(DBG_INIT, DBG_ERR, __FUNCTION__": Failed to allocate memory for RegistryPath");

        return status;
    }

    RtlCopyUnicodeString(&g_Data.RegistryPath, RegistryPath);

    // setup our dispatch function table in the driver object
    DriverObject->MajorFunction[IRP_MJ_CREATE] = testdrvCreateDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = testdrvCloseDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = testdrvDeviceIoControlDispatch;
    DriverObject->MajorFunction[IRP_MJ_READ] = testdrvReadDispatch;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = testdrvWriteDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = testdrvCleanupDispatch;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = testdrvShutdownDispatch;
    DriverObject->DriverUnload = testdrvUnload;

    // initialize device name
    RtlInitUnicodeString(&ntName, L"\\Device\\testdrvDevice");

	ExInitializeFastMutex(&qemu_output_lock);

	// Create our function device object.
    status = IoCreateDevice(
                DriverObject,
                sizeof (TESTDRV_DEVICE_EXTENSION),
                &ntName,
                FILE_DEVICE_UNKNOWN,
                0,
                FALSE,
                &deviceObject
                );

    if (!NT_SUCCESS (status)) 
    {
        ExFreePool(g_Data.RegistryPath.Buffer);
        g_Data.RegistryPath.Buffer = NULL;

        testdrvDebugPrint(DBG_INIT, DBG_ERR, __FUNCTION__"--. STATUS %x", status);

        return status;
    }

    // Initialize the device extension.
    deviceExtension = (PTESTDRV_DEVICE_EXTENSION)deviceObject->DeviceExtension;

    // Zero the memory
    RtlZeroMemory(deviceExtension, sizeof(TESTDRV_DEVICE_EXTENSION));

    // save our device object pointer
    deviceExtension->DeviceObject = deviceObject;

    // This flag sets the buffering method for reads and writes
    // to METHOD_DIRECT.  IOCTLs are handled by IO control codes
    // independent of the value of this flag.
    deviceObject->Flags |= DO_DIRECT_IO;

    RtlInitUnicodeString(&win32Name, L"\\??\\testdrvDevice");
    status = IoCreateSymbolicLink(&win32Name, &ntName);
    if (!NT_SUCCESS(status))
    {
        IoDeleteDevice(deviceObject);

        ExFreePool(g_Data.RegistryPath.Buffer);
        g_Data.RegistryPath.Buffer = NULL;

        return status;
    }

    IoRegisterShutdownNotification(deviceObject);

	InitializeListHead(&ModuleListHead);


	g_WorkItem = IoAllocateWorkItem(deviceObject);
	if(!g_WorkItem)
		return STATUS_INSUFFICIENT_RESOURCES;

	IoQueueWorkItem(g_WorkItem, GetSysModInfo, DelayedWorkQueue, g_WorkItem);
	//UpdateSysModuleList();


	PsSetLoadImageNotifyRoutine(LoadImageNotifyRoutine);
	PsSetCreateProcessNotifyRoutine(CreateProcessNotifyRoutine, FALSE);


    testdrvDebugPrint(DBG_INIT, DBG_TRACE, __FUNCTION__"--. STATUS %x", status);

    return status;
}





///////////////////////////////////////////////////////////////////////////////////////////////////
//  testdrvCreateDispatch
//      Dispatch routine for IRP_MJ_CREATE requests.
//
//  Arguments:
//      IN  DeviceObject
//              pointer to the device object for our device
//
//      IN  Irp
//              the create IRP
//
//  Return Value:
//      NT status code.
//
NTSTATUS testdrvCreateDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PTESTDRV_DEVICE_EXTENSION    deviceExtension;
    NTSTATUS                        status;

    testdrvDebugPrint(DBG_CREATECLOSE, DBG_TRACE, __FUNCTION__"++. IRP %p", Irp);

    deviceExtension = (PTESTDRV_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    InterlockedIncrement(&deviceExtension->OpenHandleCount);


    status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    testdrvDebugPrint(DBG_CREATECLOSE, DBG_TRACE, __FUNCTION__"--. IRP %p, STATUS %x", Irp, status);

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  testdrvCloseDispatch
//      Dispatch routine for IRP_MJ_CLOSE requests.
//
//  Arguments:
//      IN  DeviceObject
//              pointer to the device object for our device
//
//      IN  Irp
//              the close IRP
//
//  Return Value:
//      NT status code.
//
NTSTATUS testdrvCloseDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PTESTDRV_DEVICE_EXTENSION    deviceExtension;
    NTSTATUS                        status;

    testdrvDebugPrint(DBG_CREATECLOSE, DBG_TRACE, __FUNCTION__"++. IRP %p", Irp);

    deviceExtension = (PTESTDRV_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    InterlockedDecrement(&deviceExtension->OpenHandleCount);

    testdrvDebugPrint(DBG_CREATECLOSE, DBG_TRACE, __FUNCTION__"--. IRP %p, STATUS %x", Irp, status);

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  testdrvCleanupDispatch
//      Dispatch routine for IRP_MJ_CLEANUP requests.
//
//  Arguments:
//      IN  DeviceObject
//              pointer to the device object for our device
//
//      IN  Irp
//              the create IRP
//
//  Return Value:
//      NT status code.
//
NTSTATUS testdrvCleanupDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PTESTDRV_DEVICE_EXTENSION    deviceExtension;
    NTSTATUS                status;
    PIO_STACK_LOCATION      irpStack;

    testdrvDebugPrint(DBG_CREATECLOSE, DBG_TRACE, __FUNCTION__"++. IRP %p", Irp);

    deviceExtension = (PTESTDRV_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    testdrvFlushQueues(deviceExtension, irpStack->FileObject);

    status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    testdrvDebugPrint(DBG_CREATECLOSE, DBG_TRACE, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  testdrvUnload
//      Driver unload callback.
//
//  Arguments:
//      IN  DriverObject
//              pointer to the driver object
//
//  Return Value:
//      none
//
VOID testdrvUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
{
    UNICODE_STRING  win32Name;

    testdrvDebugPrint(DBG_UNLOAD, DBG_TRACE, __FUNCTION__"++");

    RtlInitUnicodeString(&win32Name, L"\\??\\testdrvDevice");
    IoDeleteSymbolicLink(&win32Name);

    IoUnregisterShutdownNotification(DriverObject->DeviceObject);

    IoDeleteDevice(DriverObject->DeviceObject);

    // The device object(s) should be NULL now
    // (since we unload, all the devices objects associated with this
    // driver must be deleted.
    ASSERT(DriverObject->DeviceObject == NULL);

    // We should not be unloaded until all the devices we control
    // have been removed from our queue.

    // release memory block allocated for registry path
    if (g_Data.RegistryPath.Buffer != NULL)
    {
        ExFreePool(g_Data.RegistryPath.Buffer);
        g_Data.RegistryPath.Buffer = NULL;
    }

    testdrvDebugPrint(DBG_UNLOAD, DBG_TRACE, __FUNCTION__"--");

#ifdef TESTDRV_WMI_TRACE
    WPP_CLEANUP(DriverObject);
#endif

    return;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  testdrvReadDispatch
//      Dispatch routine for IRP_MJ_READ requests.
//
//  Arguments:
//      IN  DeviceObject
//              pointer to the device object for our device
//
//      IN  Irp
//              the read IRP
//
//  Return Value:
//      NT status code.
//
NTSTATUS testdrvReadDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    NTSTATUS                        status;
    PTESTDRV_DEVICE_EXTENSION    deviceExtension;
    PIO_STACK_LOCATION              irpStack;
    PVOID                           readBuffer;
    ULONG                           readLength;

    testdrvDebugPrint(DBG_IO, DBG_TRACE, __FUNCTION__"++. IRP %p", Irp);

    deviceExtension = (PTESTDRV_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    // Get our IRP stack location
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // Get the read buffer length
    readLength = irpStack->Parameters.Read.Length;
    if (readLength == 0)
    {
        // just complete 0 length request
        status = STATUS_SUCCESS;

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        testdrvDebugPrint(DBG_IO, DBG_WARN, __FUNCTION__"--. IRP %p, STATUS %x", Irp, status);

        return status;
    }

    readBuffer = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority);

    status = STATUS_NOT_IMPLEMENTED;

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    testdrvDebugPrint(DBG_IO, DBG_TRACE, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  testdrvWriteDispatch
//      Dispatch routine for IRP_MJ_WRITE requests.
//
//  Arguments:
//      IN  DeviceObject
//              pointer to the device object for our device
//
//      IN  Irp
//              the write IRP
//
//  Return Value:
//      NT status code.
//
NTSTATUS testdrvWriteDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    NTSTATUS                        status;
    PTESTDRV_DEVICE_EXTENSION    deviceExtension;
    PIO_STACK_LOCATION              irpStack;
    PVOID                           writeBuffer;
    ULONG                           writeLength;

    testdrvDebugPrint(DBG_IO, DBG_TRACE, __FUNCTION__"++. IRP %p", Irp);

    deviceExtension = (PTESTDRV_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    // Get our IRP stack location
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // Get the write buffer length
    writeLength = irpStack->Parameters.Write.Length;
    if (writeLength == 0)
    {
        // just complete 0 length request
        status = STATUS_SUCCESS;

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        testdrvDebugPrint(DBG_IO, DBG_WARN, __FUNCTION__"--. IRP %p, STATUS %x", Irp, status);

        return status;
    }

    writeBuffer = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority);

    status = STATUS_NOT_IMPLEMENTED;

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    testdrvDebugPrint(DBG_IO, DBG_TRACE, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  testdrvDeviceIoControlDispatch
//      Dispatch routine for IRP_MJ_DEVICE_CONTROL requests.
//
//  Arguments:
//      IN  DeviceObject
//              pointer to the device object for our device
//
//      IN  Irp
//              the device i/o control IRP
//
//  Return Value:
//      NT status code.
//
NTSTATUS testdrvDeviceIoControlDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PIO_STACK_LOCATION              irpStack;
    NTSTATUS                        status;
    PTESTDRV_DEVICE_EXTENSION    deviceExtension;
    PVOID                           inputBuffer;
    ULONG                           inputLength;
    PVOID                           outputBuffer;
    ULONG                           outputLength;

    testdrvDebugPrint(DBG_IO, DBG_TRACE, __FUNCTION__"++. IRP %p", Irp);

    deviceExtension = (PTESTDRV_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    // Get our IRP stack location
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // Get the buffer lengths
    inputLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) 
    {
    case 0:

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;
    }

    testdrvDebugPrint(DBG_IO, DBG_TRACE, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  testdrvShutdownDispatch
//      Dispatch routine for IRP_MJ_SHUTDOWN requests.
//
//  Arguments:
//      IN  DeviceObject
//              pointer to the device object for our device
//
//      IN  Irp
//              the shutdown IRP
//
//  Return Value:
//      NT status code.
//
NTSTATUS testdrvShutdownDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    NTSTATUS                        status;
    PTESTDRV_DEVICE_EXTENSION    deviceExtension;

    testdrvDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"++. IRP %p", Irp);

    deviceExtension = (PTESTDRV_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    status = STATUS_NOT_IMPLEMENTED;

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    testdrvDebugPrint(DBG_GENERAL, DBG_TRACE, __FUNCTION__"--. IRP %p STATUS %x", Irp, status);

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//  testdrvFlushQueues
//      Flush oustanding IRPs for closed file object.
//
//  Arguments:
//      IN  DeviceExtension
//              our device extension
//
//      IN  FileObject
//              about to be closed file object
//
//  Return Value:
//      none
//
VOID testdrvFlushQueues(
    IN  PTESTDRV_DEVICE_EXTENSION   DeviceExtension,
    IN  PFILE_OBJECT            FileObject
    )
{
    ULONG   index;

    testdrvDebugPrint(DBG_IO, DBG_TRACE, __FUNCTION__"++");

    testdrvDebugPrint(DBG_IO, DBG_TRACE, __FUNCTION__"--");

    return;
}
